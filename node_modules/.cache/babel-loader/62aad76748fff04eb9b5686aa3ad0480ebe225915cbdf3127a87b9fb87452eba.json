{"ast":null,"code":"import _objectSpread from\"/Users/berat/YZM2021-Team-3/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useEffect}from'react';import apiService from'../services/api';import{toast}from'react-toastify';import{jsx as _jsx}from\"react/jsx-runtime\";const MemoryContext=/*#__PURE__*/createContext(undefined);const STORAGE_KEY='memolink_data';const getCacheKey=()=>{const token=localStorage.getItem('memolink_token');if(token){// Extract user ID from token (basic decoding)\ntry{const payload=JSON.parse(atob(token.split('.')[1]));return\"\".concat(STORAGE_KEY,\"_\").concat(payload.sub||'user');}catch(_unused){return STORAGE_KEY;}}return STORAGE_KEY;};// Helper function to load cached data and reduce duplication\nconst loadFromCache=(key,defaultValue)=>{const cacheKey=getCacheKey();const cached=localStorage.getItem(cacheKey);if(cached){try{const data=JSON.parse(cached);return data[key]||defaultValue;}catch(_unused2){return defaultValue;}}return defaultValue;};export const MemoryProvider=_ref=>{let{children}=_ref;// Initialize state from cache for instant display on page switches\nconst[memories,setMemories]=useState(()=>loadFromCache('memories',[]));const[connections,setConnections]=useState(()=>loadFromCache('connections',[]));const[darkMode,setDarkMode]=useState(()=>loadFromCache('darkMode',false));const[loading,setLoading]=useState(false);const[hasMore,setHasMore]=useState(true);const[dataLoaded,setDataLoaded]=useState(false);// Load data from backend or use cache if already loaded\nconst refreshData=async function(){let forceRefresh=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;const token=localStorage.getItem('memolink_token');if(token){// Eğer daha önce yüklendiyse ve force refresh değilse, cache kullan\nif(dataLoaded&&!forceRefresh&&memories.length>0){return;}try{setLoading(true);// İlk yüklemede son 40 memory'yi getir\nconst[memoriesResponse,connectionsData]=await Promise.all([apiService.getMemories(40,0),apiService.getConnections()]);const memoriesData=memoriesResponse.memories||[];const totalCount=memoriesResponse.totalCount||0;// Update state with fresh data from server\nsetMemories(memoriesData);setConnections(connectionsData);setHasMore(memoriesData.length<totalCount);setDataLoaded(true);// Cache the fresh data with user-specific key\nconst cacheKey=getCacheKey();const dataToSave={memories:memoriesData,connections:connectionsData,darkMode};localStorage.setItem(cacheKey,JSON.stringify(dataToSave));}catch(error){console.error('Error loading data from API:',error);}finally{setLoading(false);}}};// Load more memories for infinite scroll\nconst loadMoreMemories=async()=>{if(!hasMore||loading)return;const token=localStorage.getItem('memolink_token');if(!token)return;try{setLoading(true);const offset=memories.length;const response=await apiService.getMemories(40,offset);const moreMemories=response.memories||[];const totalCount=response.totalCount||0;if(moreMemories.length>0){setMemories(prev=>[...prev,...moreMemories]);const newTotal=memories.length+moreMemories.length;setHasMore(newTotal<totalCount);}else{setHasMore(false);}}catch(error){console.error('Error loading more memories:',error);}finally{setLoading(false);}};// Initial data load - only if not already loaded from cache\nuseEffect(()=>{const token=localStorage.getItem('memolink_token');if(token&&!dataLoaded){refreshData();}// eslint-disable-next-line\n},[]);// Save to localStorage whenever data changes (backup)\nuseEffect(()=>{const token=localStorage.getItem('memolink_token');if(token){// Only cache when logged in\nconst cacheKey=getCacheKey();const data={memories,connections,darkMode};localStorage.setItem(cacheKey,JSON.stringify(data));}},[memories,connections,darkMode]);// Apply dark mode to body\nuseEffect(()=>{if(darkMode){document.body.classList.add('dark-mode');}else{document.body.classList.remove('dark-mode');}},[darkMode]);const addMemory=async memory=>{const token=localStorage.getItem('memolink_token');if(token){// Optimistic update: Create temporary memory immediately for instant UI feedback\nconst tempId=\"temp-\".concat(Date.now());const optimisticMemory=_objectSpread(_objectSpread({},memory),{},{id:tempId,createdAt:new Date().toISOString(),tags:memory.tags||[]});setMemories(prev=>[...prev,optimisticMemory]);// API call in background - sync real data\ntry{const newMemory=await apiService.createMemory({title:memory.title,description:memory.description,image:memory.image,tags:memory.tags,date:memory.date,position:memory.position});if(!newMemory||!newMemory.id){console.error('[CONTEXT] Invalid memory returned from API');throw new Error('Invalid memory object returned from server');}// Replace temp memory with real one from server\nsetMemories(prev=>prev.map(m=>m.id===tempId?newMemory:m));toast.success('Memory added successfully!');}catch(error){console.error('Error creating memory:',error);// Rollback optimistic update on error\nsetMemories(prev=>prev.filter(m=>m.id!==tempId));toast.error('Failed to add memory. Please try again.');throw error;}}else{// Offline mode - use localStorage\nconst newMemory=_objectSpread(_objectSpread({},memory),{},{id:Date.now().toString(),createdAt:new Date().toISOString(),tags:memory.tags||[]});setMemories(prev=>[...prev,newMemory]);}};const updateMemory=async(id,updates)=>{const token=localStorage.getItem('memolink_token');if(token){// Optimistic update: Update UI immediately\nconst previousMemories=memories;setMemories(prev=>prev.map(m=>m.id===id?_objectSpread(_objectSpread({},m),updates):m));// API call in background\ntry{const updatedMemory=await apiService.updateMemory(id,updates);// Update with real data from server\nsetMemories(prev=>prev.map(m=>m.id===id?updatedMemory:m));toast.success('Memory updated successfully!');}catch(error){console.error('Error updating memory:',error);// Rollback on error\nsetMemories(previousMemories);toast.error('Failed to update memory. Please try again.');throw error;}}else{// Offline mode\nsetMemories(prev=>prev.map(m=>m.id===id?_objectSpread(_objectSpread({},m),updates):m));}};const deleteMemory=async id=>{const token=localStorage.getItem('memolink_token');if(token){// Optimistic update: Remove from UI immediately\nconst previousMemories=memories;const previousConnections=connections;setMemories(prev=>prev.filter(m=>m.id!==id));setConnections(prev=>prev.filter(c=>c.source!==id&&c.target!==id));// API call in background\ntry{await apiService.deleteMemory(id);toast.success('Memory deleted successfully!');}catch(error){console.error('Error deleting memory:',error);// Rollback on error\nsetMemories(previousMemories);setConnections(previousConnections);toast.error('Failed to delete memory. Please try again.');throw error;}}else{// Offline mode\nsetMemories(prev=>prev.filter(m=>m.id!==id));setConnections(prev=>prev.filter(c=>c.source!==id&&c.target!==id));}};const updateMemoryPosition=async(id,position)=>{const token=localStorage.getItem('memolink_token');// Always update UI immediately for smooth dragging\nsetMemories(prev=>prev.map(m=>m.id===id?_objectSpread(_objectSpread({},m),{},{position}):m));if(token){// API call in background - fire and forget for smooth UX\napiService.updateMemory(id,{position}).catch(error=>{console.error('Error updating position (background):',error);// Don't rollback position updates - user expects smooth dragging\n});}else{// Offline mode\nsetMemories(prev=>prev.map(m=>m.id===id?_objectSpread(_objectSpread({},m),{},{position}):m));}};const addConnection=async(source,target)=>{const token=localStorage.getItem('memolink_token');if(token){// Optimistic update: Add connection immediately for instant animation\nconst tempId=\"temp-conn-\".concat(Date.now(),\"-\").concat(Math.random());const optimisticConnection={id:tempId,source,target};// Check if connection already exists\nconst exists=connections.some(c=>c.source===source&&c.target===target||c.source===target&&c.target===source);if(exists){return;// Don't add duplicate\n}setConnections(prev=>[...prev,optimisticConnection]);// API call in background\ntry{const newConnection=await apiService.createConnection(source,target);// Replace temp connection with real one\nsetConnections(prev=>prev.map(c=>c.id===tempId?newConnection:c));toast.success('Connection created!');}catch(error){console.error('Error creating connection:',error);// Rollback optimistic update on error\nsetConnections(prev=>prev.filter(c=>c.id!==tempId));toast.error('Failed to create connection.');throw error;}}else{// Offline mode\nconst newConnection={id:\"connection-\".concat(Date.now(),\"-\").concat(Math.random()),source,target};setConnections(prev=>{const exists=prev.some(c=>c.source===source&&c.target===target||c.source===target&&c.target===source);if(exists){return prev;}return[...prev,newConnection];});}};const deleteConnection=async id=>{const token=localStorage.getItem('memolink_token');if(token){// Optimistic update: Remove from UI immediately\nconst previousConnections=connections;setConnections(prev=>prev.filter(c=>c.id!==id));// API call in background\ntry{await apiService.deleteConnection(id);toast.success('Connection deleted!');}catch(error){console.error('Error deleting connection:',error);// Rollback on error\nsetConnections(previousConnections);toast.error('Failed to delete connection.');throw error;}}else{// Offline mode\nsetConnections(prev=>prev.filter(c=>c.id!==id));}};const toggleDarkMode=()=>{setDarkMode(prev=>!prev);};const clearAllData=()=>{setMemories([]);setConnections([]);setDataLoaded(false);setHasMore(true);// Remove user-specific cache on logout\nconst cacheKey=getCacheKey();localStorage.removeItem(cacheKey);// Also remove old non-user-specific cache if exists\nlocalStorage.removeItem(STORAGE_KEY);};return/*#__PURE__*/_jsx(MemoryContext.Provider,{value:{memories,connections,darkMode,loading,hasMore,addMemory,updateMemory,deleteMemory,updateMemoryPosition,addConnection,deleteConnection,toggleDarkMode,refreshData,loadMoreMemories,clearAllData},children:children});};export const useMemory=()=>{const context=useContext(MemoryContext);if(!context){throw new Error('useMemory must be used within MemoryProvider');}return context;};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","apiService","toast","jsx","_jsx","MemoryContext","undefined","STORAGE_KEY","getCacheKey","token","localStorage","getItem","payload","JSON","parse","atob","split","concat","sub","_unused","loadFromCache","key","defaultValue","cacheKey","cached","data","_unused2","MemoryProvider","_ref","children","memories","setMemories","connections","setConnections","darkMode","setDarkMode","loading","setLoading","hasMore","setHasMore","dataLoaded","setDataLoaded","refreshData","forceRefresh","arguments","length","memoriesResponse","connectionsData","Promise","all","getMemories","getConnections","memoriesData","totalCount","dataToSave","setItem","stringify","error","console","loadMoreMemories","offset","response","moreMemories","prev","newTotal","document","body","classList","add","remove","addMemory","memory","tempId","Date","now","optimisticMemory","_objectSpread","id","createdAt","toISOString","tags","newMemory","createMemory","title","description","image","date","position","Error","map","m","success","filter","toString","updateMemory","updates","previousMemories","updatedMemory","deleteMemory","previousConnections","c","source","target","updateMemoryPosition","catch","addConnection","Math","random","optimisticConnection","exists","some","newConnection","createConnection","deleteConnection","toggleDarkMode","clearAllData","removeItem","Provider","value","useMemory","context"],"sources":["/Users/berat/YZM2021-Team-3/src/context/MemoryContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { Memory, Connection, AppState } from '../types';\nimport apiService from '../services/api';\nimport { toast } from 'react-toastify';\n\ninterface MemoryContextType {\n  memories: Memory[];\n  connections: Connection[];\n  darkMode: boolean;\n  loading: boolean;\n  hasMore: boolean;\n  addMemory: (memory: Omit<Memory, 'id' | 'createdAt'>) => Promise<void>;\n  updateMemory: (id: string, updates: Partial<Memory>) => Promise<void>;\n  deleteMemory: (id: string) => Promise<void>;\n  updateMemoryPosition: (id: string, position: { x: number; y: number }) => Promise<void>;\n  addConnection: (source: string, target: string) => Promise<void>;\n  deleteConnection: (id: string) => Promise<void>;\n  toggleDarkMode: () => void;\n  refreshData: () => Promise<void>;\n  loadMoreMemories: () => Promise<void>;\n  clearAllData: () => void;\n}\n\nconst MemoryContext = createContext<MemoryContextType | undefined>(undefined);\n\nconst STORAGE_KEY = 'memolink_data';\nconst getCacheKey = () => {\n  const token = localStorage.getItem('memolink_token');\n  if (token) {\n    // Extract user ID from token (basic decoding)\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return `${STORAGE_KEY}_${payload.sub || 'user'}`;\n    } catch {\n      return STORAGE_KEY;\n    }\n  }\n  return STORAGE_KEY;\n};\n\n// Helper function to load cached data and reduce duplication\nconst loadFromCache = <T,>(key: keyof AppState, defaultValue: T): T => {\n  const cacheKey = getCacheKey();\n  const cached = localStorage.getItem(cacheKey);\n  if (cached) {\n    try {\n      const data: AppState = JSON.parse(cached);\n      return (data[key] as T) || defaultValue;\n    } catch {\n      return defaultValue;\n    }\n  }\n  return defaultValue;\n};\n\n\nexport const MemoryProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  // Initialize state from cache for instant display on page switches\n  const [memories, setMemories] = useState<Memory[]>(() => loadFromCache('memories', []));\n  const [connections, setConnections] = useState<Connection[]>(() => loadFromCache('connections', []));\n  const [darkMode, setDarkMode] = useState<boolean>(() => loadFromCache('darkMode', false));\n  const [loading, setLoading] = useState<boolean>(false);\n  const [hasMore, setHasMore] = useState<boolean>(true);\n  const [dataLoaded, setDataLoaded] = useState<boolean>(false);\n\n  // Load data from backend or use cache if already loaded\n  const refreshData = async (forceRefresh: boolean = false) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Eğer daha önce yüklendiyse ve force refresh değilse, cache kullan\n      if (dataLoaded && !forceRefresh && memories.length > 0) {\n        return;\n      }\n      \n      try {\n        setLoading(true);\n        \n        // İlk yüklemede son 40 memory'yi getir\n        const [memoriesResponse, connectionsData] = await Promise.all([\n          apiService.getMemories(40, 0),\n          apiService.getConnections()\n        ]);\n        \n        const memoriesData = memoriesResponse.memories || [];\n        const totalCount = memoriesResponse.totalCount || 0;\n        \n        // Update state with fresh data from server\n        setMemories(memoriesData);\n        setConnections(connectionsData);\n        setHasMore(memoriesData.length < totalCount);\n        setDataLoaded(true);\n        \n        // Cache the fresh data with user-specific key\n        const cacheKey = getCacheKey();\n        const dataToSave: AppState = {\n          memories: memoriesData,\n          connections: connectionsData,\n          darkMode\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(dataToSave));\n      } catch (error) {\n        console.error('Error loading data from API:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n  };\n\n  // Load more memories for infinite scroll\n  const loadMoreMemories = async () => {\n    if (!hasMore || loading) return;\n    \n    const token = localStorage.getItem('memolink_token');\n    if (!token) return;\n    \n    try {\n      setLoading(true);\n      const offset = memories.length;\n      const response = await apiService.getMemories(40, offset);\n      const moreMemories = response.memories || [];\n      const totalCount = response.totalCount || 0;\n      \n      if (moreMemories.length > 0) {\n        setMemories(prev => [...prev, ...moreMemories]);\n        const newTotal = memories.length + moreMemories.length;\n        setHasMore(newTotal < totalCount);\n      } else {\n        setHasMore(false);\n      }\n    } catch (error) {\n      console.error('Error loading more memories:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Initial data load - only if not already loaded from cache\n  useEffect(() => {\n    const token = localStorage.getItem('memolink_token');\n    if (token && !dataLoaded) {\n      refreshData();\n    }\n    // eslint-disable-next-line\n  }, []);\n\n  // Save to localStorage whenever data changes (backup)\n  useEffect(() => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Only cache when logged in\n      const cacheKey = getCacheKey();\n      const data: AppState = { memories, connections, darkMode };\n      localStorage.setItem(cacheKey, JSON.stringify(data));\n    }\n  }, [memories, connections, darkMode]);\n\n  // Apply dark mode to body\n  useEffect(() => {\n    if (darkMode) {\n      document.body.classList.add('dark-mode');\n    } else {\n      document.body.classList.remove('dark-mode');\n    }\n  }, [darkMode]);\n\n  const addMemory = async (memory: Omit<Memory, 'id' | 'createdAt'>) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Create temporary memory immediately for instant UI feedback\n      const tempId = `temp-${Date.now()}`;\n      const optimisticMemory: Memory = {\n        ...memory,\n        id: tempId,\n        createdAt: new Date().toISOString(),\n        tags: memory.tags || [],\n      };\n      setMemories(prev => [...prev, optimisticMemory]);\n      \n      // API call in background - sync real data\n      try {\n        const newMemory = await apiService.createMemory({\n          title: memory.title,\n          description: memory.description,\n          image: memory.image,\n          tags: memory.tags,\n          date: memory.date,\n          position: memory.position\n        });\n        \n        if (!newMemory || !newMemory.id) {\n          console.error('[CONTEXT] Invalid memory returned from API');\n          throw new Error('Invalid memory object returned from server');\n        }\n        \n        // Replace temp memory with real one from server\n        setMemories(prev => prev.map(m => m.id === tempId ? newMemory : m));\n        toast.success('Memory added successfully!');\n      } catch (error) {\n        console.error('Error creating memory:', error);\n        // Rollback optimistic update on error\n        setMemories(prev => prev.filter(m => m.id !== tempId));\n        toast.error('Failed to add memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode - use localStorage\n      const newMemory: Memory = {\n        ...memory,\n        id: Date.now().toString(),\n        createdAt: new Date().toISOString(),\n        tags: memory.tags || [],\n      };\n      setMemories(prev => [...prev, newMemory]);\n    }\n  };\n\n  const updateMemory = async (id: string, updates: Partial<Memory>) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Update UI immediately\n      const previousMemories = memories;\n      setMemories(prev =>\n        prev.map(m => (m.id === id ? { ...m, ...updates } : m))\n      );\n      \n      // API call in background\n      try {\n        const updatedMemory = await apiService.updateMemory(id, updates);\n        // Update with real data from server\n        setMemories(prev =>\n          prev.map(m => (m.id === id ? updatedMemory : m))\n        );\n        toast.success('Memory updated successfully!');\n      } catch (error) {\n        console.error('Error updating memory:', error);\n        // Rollback on error\n        setMemories(previousMemories);\n        toast.error('Failed to update memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setMemories(prev =>\n        prev.map(m => (m.id === id ? { ...m, ...updates } : m))\n      );\n    }\n  };\n\n  const deleteMemory = async (id: string) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Remove from UI immediately\n      const previousMemories = memories;\n      const previousConnections = connections;\n      setMemories(prev => prev.filter(m => m.id !== id));\n      setConnections(prev => prev.filter(c => c.source !== id && c.target !== id));\n      \n      // API call in background\n      try {\n        await apiService.deleteMemory(id);\n        toast.success('Memory deleted successfully!');\n      } catch (error) {\n        console.error('Error deleting memory:', error);\n        // Rollback on error\n        setMemories(previousMemories);\n        setConnections(previousConnections);\n        toast.error('Failed to delete memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setMemories(prev => prev.filter(m => m.id !== id));\n      setConnections(prev => prev.filter(c => c.source !== id && c.target !== id));\n    }\n  };\n\n  const updateMemoryPosition = async (id: string, position: { x: number; y: number }) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    // Always update UI immediately for smooth dragging\n    setMemories(prev =>\n      prev.map(m => (m.id === id ? { ...m, position } : m))\n    );\n    \n    if (token) {\n      // API call in background - fire and forget for smooth UX\n      apiService.updateMemory(id, { position }).catch(error => {\n        console.error('Error updating position (background):', error);\n        // Don't rollback position updates - user expects smooth dragging\n      });\n    } else {\n      // Offline mode\n      setMemories(prev =>\n        prev.map(m => (m.id === id ? { ...m, position } : m))\n      );\n    }\n  };\n\n  const addConnection = async (source: string, target: string) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Add connection immediately for instant animation\n      const tempId = `temp-conn-${Date.now()}-${Math.random()}`;\n      const optimisticConnection: Connection = {\n        id: tempId,\n        source,\n        target,\n      };\n      \n      // Check if connection already exists\n      const exists = connections.some(c => \n        (c.source === source && c.target === target) || \n        (c.source === target && c.target === source)\n      );\n      \n      if (exists) {\n        return; // Don't add duplicate\n      }\n      \n      setConnections(prev => [...prev, optimisticConnection]);\n      \n      // API call in background\n      try {\n        const newConnection = await apiService.createConnection(source, target);\n        // Replace temp connection with real one\n        setConnections(prev => prev.map(c => c.id === tempId ? newConnection : c));\n        toast.success('Connection created!');\n      } catch (error) {\n        console.error('Error creating connection:', error);\n        // Rollback optimistic update on error\n        setConnections(prev => prev.filter(c => c.id !== tempId));\n        toast.error('Failed to create connection.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      const newConnection: Connection = {\n        id: `connection-${Date.now()}-${Math.random()}`,\n        source,\n        target,\n      };\n      setConnections(prev => {\n        const exists = prev.some(c => \n          (c.source === source && c.target === target) || \n          (c.source === target && c.target === source)\n        );\n        if (exists) {\n          return prev;\n        }\n        return [...prev, newConnection];\n      });\n    }\n  };\n\n  const deleteConnection = async (id: string) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Remove from UI immediately\n      const previousConnections = connections;\n      setConnections(prev => prev.filter(c => c.id !== id));\n      \n      // API call in background\n      try {\n        await apiService.deleteConnection(id);\n        toast.success('Connection deleted!');\n      } catch (error) {\n        console.error('Error deleting connection:', error);\n        // Rollback on error\n        setConnections(previousConnections);\n        toast.error('Failed to delete connection.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setConnections(prev => prev.filter(c => c.id !== id));\n    }\n  };\n\n  const toggleDarkMode = () => {\n    setDarkMode(prev => !prev);\n  };\n\n  const clearAllData = () => {\n    setMemories([]);\n    setConnections([]);\n    setDataLoaded(false);\n    setHasMore(true);\n    // Remove user-specific cache on logout\n    const cacheKey = getCacheKey();\n    localStorage.removeItem(cacheKey);\n    // Also remove old non-user-specific cache if exists\n    localStorage.removeItem(STORAGE_KEY);\n  };\n\n  return (\n    <MemoryContext.Provider\n      value={{\n        memories,\n        connections,\n        darkMode,\n        loading,\n        hasMore,\n        addMemory,\n        updateMemory,\n        deleteMemory,\n        updateMemoryPosition,\n        addConnection,\n        deleteConnection,\n        toggleDarkMode,\n        refreshData,\n        loadMoreMemories,\n        clearAllData,\n      }}\n    >\n      {children}\n    </MemoryContext.Provider>\n  );\n};\n\nexport const useMemory = () => {\n  const context = useContext(MemoryContext);\n  if (!context) {\n    throw new Error('useMemory must be used within MemoryProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}