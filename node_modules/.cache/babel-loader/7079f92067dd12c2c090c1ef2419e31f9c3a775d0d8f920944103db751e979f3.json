{"ast":null,"code":"var _jsxFileName = \"/Users/berat/YZM2021-Team-3/src/context/MemoryContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport apiService from '../services/api';\nimport { toast } from 'react-toastify';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MemoryContext = /*#__PURE__*/createContext(undefined);\nconst STORAGE_KEY = 'memolink_data';\nconst getCacheKey = () => {\n  const token = localStorage.getItem('memolink_token');\n  if (token) {\n    // Extract user ID from token (basic decoding)\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return `${STORAGE_KEY}_${payload.sub || 'user'}`;\n    } catch {\n      return STORAGE_KEY;\n    }\n  }\n  return STORAGE_KEY;\n};\n\n// Helper function to load cached data and reduce duplication\nconst loadFromCache = (key, defaultValue) => {\n  const cacheKey = getCacheKey();\n  const cached = localStorage.getItem(cacheKey);\n  if (cached) {\n    try {\n      const data = JSON.parse(cached);\n      return data[key] || defaultValue;\n    } catch {\n      return defaultValue;\n    }\n  }\n  return defaultValue;\n};\nexport const MemoryProvider = ({\n  children\n}) => {\n  _s();\n  // Initialize state from cache for instant display on page switches\n  const [memories, setMemories] = useState(() => loadFromCache('memories', []));\n  const [connections, setConnections] = useState(() => loadFromCache('connections', []));\n  const [darkMode, setDarkMode] = useState(() => loadFromCache('darkMode', false));\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(true);\n  const [dataLoaded, setDataLoaded] = useState(false);\n\n  // Load data from backend or use cache if already loaded\n  const refreshData = async (forceRefresh = false) => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Eğer daha önce yüklendiyse ve force refresh değilse, cache kullan\n      if (dataLoaded && !forceRefresh && memories.length > 0) {\n        return;\n      }\n      try {\n        setLoading(true);\n\n        // İlk yüklemede son 40 memory'yi getir\n        const [memoriesResponse, connectionsData] = await Promise.all([apiService.getMemories(40, 0), apiService.getConnections()]);\n        const memoriesData = memoriesResponse.memories || [];\n        const totalCount = memoriesResponse.totalCount || 0;\n\n        // Update state with fresh data from server\n        setMemories(memoriesData);\n        setConnections(connectionsData);\n        setHasMore(memoriesData.length < totalCount);\n        setDataLoaded(true);\n\n        // Cache the fresh data with user-specific key\n        const cacheKey = getCacheKey();\n        const dataToSave = {\n          memories: memoriesData,\n          connections: connectionsData,\n          darkMode\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(dataToSave));\n      } catch (error) {\n        console.error('Error loading data from API:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n  };\n\n  // Load more memories for infinite scroll\n  const loadMoreMemories = async () => {\n    if (!hasMore || loading) return;\n    const token = localStorage.getItem('memolink_token');\n    if (!token) return;\n    try {\n      setLoading(true);\n      const offset = memories.length;\n      const response = await apiService.getMemories(40, offset);\n      const moreMemories = response.memories || [];\n      const totalCount = response.totalCount || 0;\n      if (moreMemories.length > 0) {\n        setMemories(prev => [...prev, ...moreMemories]);\n        const newTotal = memories.length + moreMemories.length;\n        setHasMore(newTotal < totalCount);\n      } else {\n        setHasMore(false);\n      }\n    } catch (error) {\n      console.error('Error loading more memories:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Initial data load - only if not already loaded from cache\n  useEffect(() => {\n    const token = localStorage.getItem('memolink_token');\n    if (token && !dataLoaded) {\n      refreshData();\n    }\n    // eslint-disable-next-line\n  }, []);\n\n  // Save to localStorage whenever data changes (backup)\n  useEffect(() => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Only cache when logged in\n      const cacheKey = getCacheKey();\n      const data = {\n        memories,\n        connections,\n        darkMode\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(data));\n    }\n  }, [memories, connections, darkMode]);\n\n  // Apply dark mode to body\n  useEffect(() => {\n    if (darkMode) {\n      document.body.classList.add('dark-mode');\n    } else {\n      document.body.classList.remove('dark-mode');\n    }\n  }, [darkMode]);\n  const addMemory = async memory => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Optimistic update: Create temporary memory immediately for instant UI feedback\n      const tempId = `temp-${Date.now()}`;\n      const optimisticMemory = {\n        ...memory,\n        id: tempId,\n        createdAt: new Date().toISOString(),\n        tags: memory.tags || []\n      };\n      setMemories(prev => [...prev, optimisticMemory]);\n\n      // API call in background - sync real data\n      try {\n        const newMemory = await apiService.createMemory({\n          title: memory.title,\n          description: memory.description,\n          image: memory.image,\n          tags: memory.tags,\n          date: memory.date,\n          position: memory.position\n        });\n        if (!newMemory || !newMemory.id) {\n          console.error('[CONTEXT] Invalid memory returned from API');\n          throw new Error('Invalid memory object returned from server');\n        }\n\n        // Replace temp memory with real one from server\n        setMemories(prev => prev.map(m => m.id === tempId ? newMemory : m));\n        toast.success('Memory added successfully!');\n      } catch (error) {\n        console.error('Error creating memory:', error);\n        // Rollback optimistic update on error\n        setMemories(prev => prev.filter(m => m.id !== tempId));\n        toast.error('Failed to add memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode - use localStorage\n      const newMemory = {\n        ...memory,\n        id: Date.now().toString(),\n        createdAt: new Date().toISOString(),\n        tags: memory.tags || []\n      };\n      setMemories(prev => [...prev, newMemory]);\n    }\n  };\n  const updateMemory = async (id, updates) => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Optimistic update: Update UI immediately\n      const previousMemories = memories;\n      setMemories(prev => prev.map(m => m.id === id ? {\n        ...m,\n        ...updates\n      } : m));\n\n      // API call in background\n      try {\n        const updatedMemory = await apiService.updateMemory(id, updates);\n        // Update with real data from server\n        setMemories(prev => prev.map(m => m.id === id ? updatedMemory : m));\n        toast.success('Memory updated successfully!');\n      } catch (error) {\n        console.error('Error updating memory:', error);\n        // Rollback on error\n        setMemories(previousMemories);\n        toast.error('Failed to update memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setMemories(prev => prev.map(m => m.id === id ? {\n        ...m,\n        ...updates\n      } : m));\n    }\n  };\n  const deleteMemory = async id => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Optimistic update: Remove from UI immediately\n      const previousMemories = memories;\n      const previousConnections = connections;\n      setMemories(prev => prev.filter(m => m.id !== id));\n      setConnections(prev => prev.filter(c => c.source !== id && c.target !== id));\n\n      // API call in background\n      try {\n        await apiService.deleteMemory(id);\n        toast.success('Memory deleted successfully!');\n      } catch (error) {\n        console.error('Error deleting memory:', error);\n        // Rollback on error\n        setMemories(previousMemories);\n        setConnections(previousConnections);\n        toast.error('Failed to delete memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setMemories(prev => prev.filter(m => m.id !== id));\n      setConnections(prev => prev.filter(c => c.source !== id && c.target !== id));\n    }\n  };\n  const updateMemoryPosition = async (id, position) => {\n    const token = localStorage.getItem('memolink_token');\n\n    // Always update UI immediately for smooth dragging\n    setMemories(prev => prev.map(m => m.id === id ? {\n      ...m,\n      position\n    } : m));\n    if (token) {\n      // API call in background - fire and forget for smooth UX\n      apiService.updateMemory(id, {\n        position\n      }).catch(error => {\n        console.error('Error updating position (background):', error);\n        // Don't rollback position updates - user expects smooth dragging\n      });\n    } else {\n      // Offline mode\n      setMemories(prev => prev.map(m => m.id === id ? {\n        ...m,\n        position\n      } : m));\n    }\n  };\n  const addConnection = async (source, target) => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Optimistic update: Add connection immediately for instant animation\n      const tempId = `temp-conn-${Date.now()}-${Math.random()}`;\n      const optimisticConnection = {\n        id: tempId,\n        source,\n        target\n      };\n\n      // Check if connection already exists\n      const exists = connections.some(c => c.source === source && c.target === target || c.source === target && c.target === source);\n      if (exists) {\n        return; // Don't add duplicate\n      }\n      setConnections(prev => [...prev, optimisticConnection]);\n\n      // API call in background\n      try {\n        const newConnection = await apiService.createConnection(source, target);\n        // Replace temp connection with real one\n        setConnections(prev => prev.map(c => c.id === tempId ? newConnection : c));\n        toast.success('Connection created!');\n      } catch (error) {\n        console.error('Error creating connection:', error);\n        // Rollback optimistic update on error\n        setConnections(prev => prev.filter(c => c.id !== tempId));\n        toast.error('Failed to create connection.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      const newConnection = {\n        id: `connection-${Date.now()}-${Math.random()}`,\n        source,\n        target\n      };\n      setConnections(prev => {\n        const exists = prev.some(c => c.source === source && c.target === target || c.source === target && c.target === source);\n        if (exists) {\n          return prev;\n        }\n        return [...prev, newConnection];\n      });\n    }\n  };\n  const deleteConnection = async id => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Optimistic update: Remove from UI immediately\n      const previousConnections = connections;\n      setConnections(prev => prev.filter(c => c.id !== id));\n\n      // API call in background\n      try {\n        await apiService.deleteConnection(id);\n        toast.success('Connection deleted!');\n      } catch (error) {\n        console.error('Error deleting connection:', error);\n        // Rollback on error\n        setConnections(previousConnections);\n        toast.error('Failed to delete connection.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setConnections(prev => prev.filter(c => c.id !== id));\n    }\n  };\n  const toggleDarkMode = () => {\n    setDarkMode(prev => !prev);\n  };\n  const clearAllData = () => {\n    setMemories([]);\n    setConnections([]);\n    setDataLoaded(false);\n    setHasMore(true);\n    // Remove user-specific cache on logout\n    const cacheKey = getCacheKey();\n    localStorage.removeItem(cacheKey);\n    // Also remove old non-user-specific cache if exists\n    localStorage.removeItem(STORAGE_KEY);\n  };\n  return /*#__PURE__*/_jsxDEV(MemoryContext.Provider, {\n    value: {\n      memories,\n      connections,\n      darkMode,\n      loading,\n      hasMore,\n      addMemory,\n      updateMemory,\n      deleteMemory,\n      updateMemoryPosition,\n      addConnection,\n      deleteConnection,\n      toggleDarkMode,\n      refreshData,\n      loadMoreMemories,\n      clearAllData\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 402,\n    columnNumber: 5\n  }, this);\n};\n_s(MemoryProvider, \"R4BstlEgubHthjNyOxmEQkGipXg=\");\n_c = MemoryProvider;\nexport const useMemory = () => {\n  _s2();\n  const context = useContext(MemoryContext);\n  if (!context) {\n    throw new Error('useMemory must be used within MemoryProvider');\n  }\n  return context;\n};\n_s2(useMemory, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"MemoryProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","apiService","toast","jsxDEV","_jsxDEV","MemoryContext","undefined","STORAGE_KEY","getCacheKey","token","localStorage","getItem","payload","JSON","parse","atob","split","sub","loadFromCache","key","defaultValue","cacheKey","cached","data","MemoryProvider","children","_s","memories","setMemories","connections","setConnections","darkMode","setDarkMode","loading","setLoading","hasMore","setHasMore","dataLoaded","setDataLoaded","refreshData","forceRefresh","length","memoriesResponse","connectionsData","Promise","all","getMemories","getConnections","memoriesData","totalCount","dataToSave","setItem","stringify","error","console","loadMoreMemories","offset","response","moreMemories","prev","newTotal","document","body","classList","add","remove","addMemory","memory","tempId","Date","now","optimisticMemory","id","createdAt","toISOString","tags","newMemory","createMemory","title","description","image","date","position","Error","map","m","success","filter","toString","updateMemory","updates","previousMemories","updatedMemory","deleteMemory","previousConnections","c","source","target","updateMemoryPosition","catch","addConnection","Math","random","optimisticConnection","exists","some","newConnection","createConnection","deleteConnection","toggleDarkMode","clearAllData","removeItem","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useMemory","_s2","context","$RefreshReg$"],"sources":["/Users/berat/YZM2021-Team-3/src/context/MemoryContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { Memory, Connection, AppState } from '../types';\nimport apiService from '../services/api';\nimport { toast } from 'react-toastify';\n\ninterface MemoryContextType {\n  memories: Memory[];\n  connections: Connection[];\n  darkMode: boolean;\n  loading: boolean;\n  hasMore: boolean;\n  addMemory: (memory: Omit<Memory, 'id' | 'createdAt'>) => Promise<void>;\n  updateMemory: (id: string, updates: Partial<Memory>) => Promise<void>;\n  deleteMemory: (id: string) => Promise<void>;\n  updateMemoryPosition: (id: string, position: { x: number; y: number }) => Promise<void>;\n  addConnection: (source: string, target: string) => Promise<void>;\n  deleteConnection: (id: string) => Promise<void>;\n  toggleDarkMode: () => void;\n  refreshData: () => Promise<void>;\n  loadMoreMemories: () => Promise<void>;\n  clearAllData: () => void;\n}\n\nconst MemoryContext = createContext<MemoryContextType | undefined>(undefined);\n\nconst STORAGE_KEY = 'memolink_data';\nconst getCacheKey = () => {\n  const token = localStorage.getItem('memolink_token');\n  if (token) {\n    // Extract user ID from token (basic decoding)\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return `${STORAGE_KEY}_${payload.sub || 'user'}`;\n    } catch {\n      return STORAGE_KEY;\n    }\n  }\n  return STORAGE_KEY;\n};\n\n// Helper function to load cached data and reduce duplication\nconst loadFromCache = <T,>(key: keyof AppState, defaultValue: T): T => {\n  const cacheKey = getCacheKey();\n  const cached = localStorage.getItem(cacheKey);\n  if (cached) {\n    try {\n      const data: AppState = JSON.parse(cached);\n      return (data[key] as T) || defaultValue;\n    } catch {\n      return defaultValue;\n    }\n  }\n  return defaultValue;\n};\n\n\nexport const MemoryProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  // Initialize state from cache for instant display on page switches\n  const [memories, setMemories] = useState<Memory[]>(() => loadFromCache('memories', []));\n  const [connections, setConnections] = useState<Connection[]>(() => loadFromCache('connections', []));\n  const [darkMode, setDarkMode] = useState<boolean>(() => loadFromCache('darkMode', false));\n  const [loading, setLoading] = useState<boolean>(false);\n  const [hasMore, setHasMore] = useState<boolean>(true);\n  const [dataLoaded, setDataLoaded] = useState<boolean>(false);\n\n  // Load data from backend or use cache if already loaded\n  const refreshData = async (forceRefresh: boolean = false) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Eğer daha önce yüklendiyse ve force refresh değilse, cache kullan\n      if (dataLoaded && !forceRefresh && memories.length > 0) {\n        return;\n      }\n      \n      try {\n        setLoading(true);\n        \n        // İlk yüklemede son 40 memory'yi getir\n        const [memoriesResponse, connectionsData] = await Promise.all([\n          apiService.getMemories(40, 0),\n          apiService.getConnections()\n        ]);\n        \n        const memoriesData = memoriesResponse.memories || [];\n        const totalCount = memoriesResponse.totalCount || 0;\n        \n        // Update state with fresh data from server\n        setMemories(memoriesData);\n        setConnections(connectionsData);\n        setHasMore(memoriesData.length < totalCount);\n        setDataLoaded(true);\n        \n        // Cache the fresh data with user-specific key\n        const cacheKey = getCacheKey();\n        const dataToSave: AppState = {\n          memories: memoriesData,\n          connections: connectionsData,\n          darkMode\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(dataToSave));\n      } catch (error) {\n        console.error('Error loading data from API:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n  };\n\n  // Load more memories for infinite scroll\n  const loadMoreMemories = async () => {\n    if (!hasMore || loading) return;\n    \n    const token = localStorage.getItem('memolink_token');\n    if (!token) return;\n    \n    try {\n      setLoading(true);\n      const offset = memories.length;\n      const response = await apiService.getMemories(40, offset);\n      const moreMemories = response.memories || [];\n      const totalCount = response.totalCount || 0;\n      \n      if (moreMemories.length > 0) {\n        setMemories(prev => [...prev, ...moreMemories]);\n        const newTotal = memories.length + moreMemories.length;\n        setHasMore(newTotal < totalCount);\n      } else {\n        setHasMore(false);\n      }\n    } catch (error) {\n      console.error('Error loading more memories:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Initial data load - only if not already loaded from cache\n  useEffect(() => {\n    const token = localStorage.getItem('memolink_token');\n    if (token && !dataLoaded) {\n      refreshData();\n    }\n    // eslint-disable-next-line\n  }, []);\n\n  // Save to localStorage whenever data changes (backup)\n  useEffect(() => {\n    const token = localStorage.getItem('memolink_token');\n    if (token) {\n      // Only cache when logged in\n      const cacheKey = getCacheKey();\n      const data: AppState = { memories, connections, darkMode };\n      localStorage.setItem(cacheKey, JSON.stringify(data));\n    }\n  }, [memories, connections, darkMode]);\n\n  // Apply dark mode to body\n  useEffect(() => {\n    if (darkMode) {\n      document.body.classList.add('dark-mode');\n    } else {\n      document.body.classList.remove('dark-mode');\n    }\n  }, [darkMode]);\n\n  const addMemory = async (memory: Omit<Memory, 'id' | 'createdAt'>) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Create temporary memory immediately for instant UI feedback\n      const tempId = `temp-${Date.now()}`;\n      const optimisticMemory: Memory = {\n        ...memory,\n        id: tempId,\n        createdAt: new Date().toISOString(),\n        tags: memory.tags || [],\n      };\n      setMemories(prev => [...prev, optimisticMemory]);\n      \n      // API call in background - sync real data\n      try {\n        const newMemory = await apiService.createMemory({\n          title: memory.title,\n          description: memory.description,\n          image: memory.image,\n          tags: memory.tags,\n          date: memory.date,\n          position: memory.position\n        });\n        \n        if (!newMemory || !newMemory.id) {\n          console.error('[CONTEXT] Invalid memory returned from API');\n          throw new Error('Invalid memory object returned from server');\n        }\n        \n        // Replace temp memory with real one from server\n        setMemories(prev => prev.map(m => m.id === tempId ? newMemory : m));\n        toast.success('Memory added successfully!');\n      } catch (error) {\n        console.error('Error creating memory:', error);\n        // Rollback optimistic update on error\n        setMemories(prev => prev.filter(m => m.id !== tempId));\n        toast.error('Failed to add memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode - use localStorage\n      const newMemory: Memory = {\n        ...memory,\n        id: Date.now().toString(),\n        createdAt: new Date().toISOString(),\n        tags: memory.tags || [],\n      };\n      setMemories(prev => [...prev, newMemory]);\n    }\n  };\n\n  const updateMemory = async (id: string, updates: Partial<Memory>) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Update UI immediately\n      const previousMemories = memories;\n      setMemories(prev =>\n        prev.map(m => (m.id === id ? { ...m, ...updates } : m))\n      );\n      \n      // API call in background\n      try {\n        const updatedMemory = await apiService.updateMemory(id, updates);\n        // Update with real data from server\n        setMemories(prev =>\n          prev.map(m => (m.id === id ? updatedMemory : m))\n        );\n        toast.success('Memory updated successfully!');\n      } catch (error) {\n        console.error('Error updating memory:', error);\n        // Rollback on error\n        setMemories(previousMemories);\n        toast.error('Failed to update memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setMemories(prev =>\n        prev.map(m => (m.id === id ? { ...m, ...updates } : m))\n      );\n    }\n  };\n\n  const deleteMemory = async (id: string) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Remove from UI immediately\n      const previousMemories = memories;\n      const previousConnections = connections;\n      setMemories(prev => prev.filter(m => m.id !== id));\n      setConnections(prev => prev.filter(c => c.source !== id && c.target !== id));\n      \n      // API call in background\n      try {\n        await apiService.deleteMemory(id);\n        toast.success('Memory deleted successfully!');\n      } catch (error) {\n        console.error('Error deleting memory:', error);\n        // Rollback on error\n        setMemories(previousMemories);\n        setConnections(previousConnections);\n        toast.error('Failed to delete memory. Please try again.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setMemories(prev => prev.filter(m => m.id !== id));\n      setConnections(prev => prev.filter(c => c.source !== id && c.target !== id));\n    }\n  };\n\n  const updateMemoryPosition = async (id: string, position: { x: number; y: number }) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    // Always update UI immediately for smooth dragging\n    setMemories(prev =>\n      prev.map(m => (m.id === id ? { ...m, position } : m))\n    );\n    \n    if (token) {\n      // API call in background - fire and forget for smooth UX\n      apiService.updateMemory(id, { position }).catch(error => {\n        console.error('Error updating position (background):', error);\n        // Don't rollback position updates - user expects smooth dragging\n      });\n    } else {\n      // Offline mode\n      setMemories(prev =>\n        prev.map(m => (m.id === id ? { ...m, position } : m))\n      );\n    }\n  };\n\n  const addConnection = async (source: string, target: string) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Add connection immediately for instant animation\n      const tempId = `temp-conn-${Date.now()}-${Math.random()}`;\n      const optimisticConnection: Connection = {\n        id: tempId,\n        source,\n        target,\n      };\n      \n      // Check if connection already exists\n      const exists = connections.some(c => \n        (c.source === source && c.target === target) || \n        (c.source === target && c.target === source)\n      );\n      \n      if (exists) {\n        return; // Don't add duplicate\n      }\n      \n      setConnections(prev => [...prev, optimisticConnection]);\n      \n      // API call in background\n      try {\n        const newConnection = await apiService.createConnection(source, target);\n        // Replace temp connection with real one\n        setConnections(prev => prev.map(c => c.id === tempId ? newConnection : c));\n        toast.success('Connection created!');\n      } catch (error) {\n        console.error('Error creating connection:', error);\n        // Rollback optimistic update on error\n        setConnections(prev => prev.filter(c => c.id !== tempId));\n        toast.error('Failed to create connection.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      const newConnection: Connection = {\n        id: `connection-${Date.now()}-${Math.random()}`,\n        source,\n        target,\n      };\n      setConnections(prev => {\n        const exists = prev.some(c => \n          (c.source === source && c.target === target) || \n          (c.source === target && c.target === source)\n        );\n        if (exists) {\n          return prev;\n        }\n        return [...prev, newConnection];\n      });\n    }\n  };\n\n  const deleteConnection = async (id: string) => {\n    const token = localStorage.getItem('memolink_token');\n    \n    if (token) {\n      // Optimistic update: Remove from UI immediately\n      const previousConnections = connections;\n      setConnections(prev => prev.filter(c => c.id !== id));\n      \n      // API call in background\n      try {\n        await apiService.deleteConnection(id);\n        toast.success('Connection deleted!');\n      } catch (error) {\n        console.error('Error deleting connection:', error);\n        // Rollback on error\n        setConnections(previousConnections);\n        toast.error('Failed to delete connection.');\n        throw error;\n      }\n    } else {\n      // Offline mode\n      setConnections(prev => prev.filter(c => c.id !== id));\n    }\n  };\n\n  const toggleDarkMode = () => {\n    setDarkMode(prev => !prev);\n  };\n\n  const clearAllData = () => {\n    setMemories([]);\n    setConnections([]);\n    setDataLoaded(false);\n    setHasMore(true);\n    // Remove user-specific cache on logout\n    const cacheKey = getCacheKey();\n    localStorage.removeItem(cacheKey);\n    // Also remove old non-user-specific cache if exists\n    localStorage.removeItem(STORAGE_KEY);\n  };\n\n  return (\n    <MemoryContext.Provider\n      value={{\n        memories,\n        connections,\n        darkMode,\n        loading,\n        hasMore,\n        addMemory,\n        updateMemory,\n        deleteMemory,\n        updateMemoryPosition,\n        addConnection,\n        deleteConnection,\n        toggleDarkMode,\n        refreshData,\n        loadMoreMemories,\n        clearAllData,\n      }}\n    >\n      {children}\n    </MemoryContext.Provider>\n  );\n};\n\nexport const useMemory = () => {\n  const context = useContext(MemoryContext);\n  if (!context) {\n    throw new Error('useMemory must be used within MemoryProvider');\n  }\n  return context;\n};\n"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,QAAmB,OAAO;AAExF,OAAOC,UAAU,MAAM,iBAAiB;AACxC,SAASC,KAAK,QAAQ,gBAAgB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAoBvC,MAAMC,aAAa,gBAAGR,aAAa,CAAgCS,SAAS,CAAC;AAE7E,MAAMC,WAAW,GAAG,eAAe;AACnC,MAAMC,WAAW,GAAGA,CAAA,KAAM;EACxB,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;EACpD,IAAIF,KAAK,EAAE;IACT;IACA,IAAI;MACF,MAAMG,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACN,KAAK,CAACO,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACrD,OAAO,GAAGT,WAAW,IAAIK,OAAO,CAACK,GAAG,IAAI,MAAM,EAAE;IAClD,CAAC,CAAC,MAAM;MACN,OAAOV,WAAW;IACpB;EACF;EACA,OAAOA,WAAW;AACpB,CAAC;;AAED;AACA,MAAMW,aAAa,GAAGA,CAAKC,GAAmB,EAAEC,YAAe,KAAQ;EACrE,MAAMC,QAAQ,GAAGb,WAAW,CAAC,CAAC;EAC9B,MAAMc,MAAM,GAAGZ,YAAY,CAACC,OAAO,CAACU,QAAQ,CAAC;EAC7C,IAAIC,MAAM,EAAE;IACV,IAAI;MACF,MAAMC,IAAc,GAAGV,IAAI,CAACC,KAAK,CAACQ,MAAM,CAAC;MACzC,OAAQC,IAAI,CAACJ,GAAG,CAAC,IAAUC,YAAY;IACzC,CAAC,CAAC,MAAM;MACN,OAAOA,YAAY;IACrB;EACF;EACA,OAAOA,YAAY;AACrB,CAAC;AAGD,OAAO,MAAMI,cAAiD,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EACjF;EACA,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAG7B,QAAQ,CAAW,MAAMmB,aAAa,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;EACvF,MAAM,CAACW,WAAW,EAAEC,cAAc,CAAC,GAAG/B,QAAQ,CAAe,MAAMmB,aAAa,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;EACpG,MAAM,CAACa,QAAQ,EAAEC,WAAW,CAAC,GAAGjC,QAAQ,CAAU,MAAMmB,aAAa,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;EACzF,MAAM,CAACe,OAAO,EAAEC,UAAU,CAAC,GAAGnC,QAAQ,CAAU,KAAK,CAAC;EACtD,MAAM,CAACoC,OAAO,EAAEC,UAAU,CAAC,GAAGrC,QAAQ,CAAU,IAAI,CAAC;EACrD,MAAM,CAACsC,UAAU,EAAEC,aAAa,CAAC,GAAGvC,QAAQ,CAAU,KAAK,CAAC;;EAE5D;EACA,MAAMwC,WAAW,GAAG,MAAAA,CAAOC,YAAqB,GAAG,KAAK,KAAK;IAC3D,MAAM/B,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IAEpD,IAAIF,KAAK,EAAE;MACT;MACA,IAAI4B,UAAU,IAAI,CAACG,YAAY,IAAIb,QAAQ,CAACc,MAAM,GAAG,CAAC,EAAE;QACtD;MACF;MAEA,IAAI;QACFP,UAAU,CAAC,IAAI,CAAC;;QAEhB;QACA,MAAM,CAACQ,gBAAgB,EAAEC,eAAe,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC5D5C,UAAU,CAAC6C,WAAW,CAAC,EAAE,EAAE,CAAC,CAAC,EAC7B7C,UAAU,CAAC8C,cAAc,CAAC,CAAC,CAC5B,CAAC;QAEF,MAAMC,YAAY,GAAGN,gBAAgB,CAACf,QAAQ,IAAI,EAAE;QACpD,MAAMsB,UAAU,GAAGP,gBAAgB,CAACO,UAAU,IAAI,CAAC;;QAEnD;QACArB,WAAW,CAACoB,YAAY,CAAC;QACzBlB,cAAc,CAACa,eAAe,CAAC;QAC/BP,UAAU,CAACY,YAAY,CAACP,MAAM,GAAGQ,UAAU,CAAC;QAC5CX,aAAa,CAAC,IAAI,CAAC;;QAEnB;QACA,MAAMjB,QAAQ,GAAGb,WAAW,CAAC,CAAC;QAC9B,MAAM0C,UAAoB,GAAG;UAC3BvB,QAAQ,EAAEqB,YAAY;UACtBnB,WAAW,EAAEc,eAAe;UAC5BZ;QACF,CAAC;QACDrB,YAAY,CAACyC,OAAO,CAAC9B,QAAQ,EAAER,IAAI,CAACuC,SAAS,CAACF,UAAU,CAAC,CAAC;MAC5D,CAAC,CAAC,OAAOG,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACtD,CAAC,SAAS;QACRnB,UAAU,CAAC,KAAK,CAAC;MACnB;IACF;EACF,CAAC;;EAED;EACA,MAAMqB,gBAAgB,GAAG,MAAAA,CAAA,KAAY;IACnC,IAAI,CAACpB,OAAO,IAAIF,OAAO,EAAE;IAEzB,MAAMxB,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IACpD,IAAI,CAACF,KAAK,EAAE;IAEZ,IAAI;MACFyB,UAAU,CAAC,IAAI,CAAC;MAChB,MAAMsB,MAAM,GAAG7B,QAAQ,CAACc,MAAM;MAC9B,MAAMgB,QAAQ,GAAG,MAAMxD,UAAU,CAAC6C,WAAW,CAAC,EAAE,EAAEU,MAAM,CAAC;MACzD,MAAME,YAAY,GAAGD,QAAQ,CAAC9B,QAAQ,IAAI,EAAE;MAC5C,MAAMsB,UAAU,GAAGQ,QAAQ,CAACR,UAAU,IAAI,CAAC;MAE3C,IAAIS,YAAY,CAACjB,MAAM,GAAG,CAAC,EAAE;QAC3Bb,WAAW,CAAC+B,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAE,GAAGD,YAAY,CAAC,CAAC;QAC/C,MAAME,QAAQ,GAAGjC,QAAQ,CAACc,MAAM,GAAGiB,YAAY,CAACjB,MAAM;QACtDL,UAAU,CAACwB,QAAQ,GAAGX,UAAU,CAAC;MACnC,CAAC,MAAM;QACLb,UAAU,CAAC,KAAK,CAAC;MACnB;IACF,CAAC,CAAC,OAAOiB,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACtD,CAAC,SAAS;MACRnB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC;;EAED;EACAlC,SAAS,CAAC,MAAM;IACd,MAAMS,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IACpD,IAAIF,KAAK,IAAI,CAAC4B,UAAU,EAAE;MACxBE,WAAW,CAAC,CAAC;IACf;IACA;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;EACAvC,SAAS,CAAC,MAAM;IACd,MAAMS,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IACpD,IAAIF,KAAK,EAAE;MACT;MACA,MAAMY,QAAQ,GAAGb,WAAW,CAAC,CAAC;MAC9B,MAAMe,IAAc,GAAG;QAAEI,QAAQ;QAAEE,WAAW;QAAEE;MAAS,CAAC;MAC1DrB,YAAY,CAACyC,OAAO,CAAC9B,QAAQ,EAAER,IAAI,CAACuC,SAAS,CAAC7B,IAAI,CAAC,CAAC;IACtD;EACF,CAAC,EAAE,CAACI,QAAQ,EAAEE,WAAW,EAAEE,QAAQ,CAAC,CAAC;;EAErC;EACA/B,SAAS,CAAC,MAAM;IACd,IAAI+B,QAAQ,EAAE;MACZ8B,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACC,GAAG,CAAC,WAAW,CAAC;IAC1C,CAAC,MAAM;MACLH,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACE,MAAM,CAAC,WAAW,CAAC;IAC7C;EACF,CAAC,EAAE,CAAClC,QAAQ,CAAC,CAAC;EAEd,MAAMmC,SAAS,GAAG,MAAOC,MAAwC,IAAK;IACpE,MAAM1D,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IAEpD,IAAIF,KAAK,EAAE;MACT;MACA,MAAM2D,MAAM,GAAG,QAAQC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACnC,MAAMC,gBAAwB,GAAG;QAC/B,GAAGJ,MAAM;QACTK,EAAE,EAAEJ,MAAM;QACVK,SAAS,EAAE,IAAIJ,IAAI,CAAC,CAAC,CAACK,WAAW,CAAC,CAAC;QACnCC,IAAI,EAAER,MAAM,CAACQ,IAAI,IAAI;MACvB,CAAC;MACD/C,WAAW,CAAC+B,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAEY,gBAAgB,CAAC,CAAC;;MAEhD;MACA,IAAI;QACF,MAAMK,SAAS,GAAG,MAAM3E,UAAU,CAAC4E,YAAY,CAAC;UAC9CC,KAAK,EAAEX,MAAM,CAACW,KAAK;UACnBC,WAAW,EAAEZ,MAAM,CAACY,WAAW;UAC/BC,KAAK,EAAEb,MAAM,CAACa,KAAK;UACnBL,IAAI,EAAER,MAAM,CAACQ,IAAI;UACjBM,IAAI,EAAEd,MAAM,CAACc,IAAI;UACjBC,QAAQ,EAAEf,MAAM,CAACe;QACnB,CAAC,CAAC;QAEF,IAAI,CAACN,SAAS,IAAI,CAACA,SAAS,CAACJ,EAAE,EAAE;UAC/BlB,OAAO,CAACD,KAAK,CAAC,4CAA4C,CAAC;UAC3D,MAAM,IAAI8B,KAAK,CAAC,4CAA4C,CAAC;QAC/D;;QAEA;QACAvD,WAAW,CAAC+B,IAAI,IAAIA,IAAI,CAACyB,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACb,EAAE,KAAKJ,MAAM,GAAGQ,SAAS,GAAGS,CAAC,CAAC,CAAC;QACnEnF,KAAK,CAACoF,OAAO,CAAC,4BAA4B,CAAC;MAC7C,CAAC,CAAC,OAAOjC,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9C;QACAzB,WAAW,CAAC+B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACF,CAAC,IAAIA,CAAC,CAACb,EAAE,KAAKJ,MAAM,CAAC,CAAC;QACtDlE,KAAK,CAACmD,KAAK,CAAC,yCAAyC,CAAC;QACtD,MAAMA,KAAK;MACb;IACF,CAAC,MAAM;MACL;MACA,MAAMuB,SAAiB,GAAG;QACxB,GAAGT,MAAM;QACTK,EAAE,EAAEH,IAAI,CAACC,GAAG,CAAC,CAAC,CAACkB,QAAQ,CAAC,CAAC;QACzBf,SAAS,EAAE,IAAIJ,IAAI,CAAC,CAAC,CAACK,WAAW,CAAC,CAAC;QACnCC,IAAI,EAAER,MAAM,CAACQ,IAAI,IAAI;MACvB,CAAC;MACD/C,WAAW,CAAC+B,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAEiB,SAAS,CAAC,CAAC;IAC3C;EACF,CAAC;EAED,MAAMa,YAAY,GAAG,MAAAA,CAAOjB,EAAU,EAAEkB,OAAwB,KAAK;IACnE,MAAMjF,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IAEpD,IAAIF,KAAK,EAAE;MACT;MACA,MAAMkF,gBAAgB,GAAGhE,QAAQ;MACjCC,WAAW,CAAC+B,IAAI,IACdA,IAAI,CAACyB,GAAG,CAACC,CAAC,IAAKA,CAAC,CAACb,EAAE,KAAKA,EAAE,GAAG;QAAE,GAAGa,CAAC;QAAE,GAAGK;MAAQ,CAAC,GAAGL,CAAE,CACxD,CAAC;;MAED;MACA,IAAI;QACF,MAAMO,aAAa,GAAG,MAAM3F,UAAU,CAACwF,YAAY,CAACjB,EAAE,EAAEkB,OAAO,CAAC;QAChE;QACA9D,WAAW,CAAC+B,IAAI,IACdA,IAAI,CAACyB,GAAG,CAACC,CAAC,IAAKA,CAAC,CAACb,EAAE,KAAKA,EAAE,GAAGoB,aAAa,GAAGP,CAAE,CACjD,CAAC;QACDnF,KAAK,CAACoF,OAAO,CAAC,8BAA8B,CAAC;MAC/C,CAAC,CAAC,OAAOjC,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9C;QACAzB,WAAW,CAAC+D,gBAAgB,CAAC;QAC7BzF,KAAK,CAACmD,KAAK,CAAC,4CAA4C,CAAC;QACzD,MAAMA,KAAK;MACb;IACF,CAAC,MAAM;MACL;MACAzB,WAAW,CAAC+B,IAAI,IACdA,IAAI,CAACyB,GAAG,CAACC,CAAC,IAAKA,CAAC,CAACb,EAAE,KAAKA,EAAE,GAAG;QAAE,GAAGa,CAAC;QAAE,GAAGK;MAAQ,CAAC,GAAGL,CAAE,CACxD,CAAC;IACH;EACF,CAAC;EAED,MAAMQ,YAAY,GAAG,MAAOrB,EAAU,IAAK;IACzC,MAAM/D,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IAEpD,IAAIF,KAAK,EAAE;MACT;MACA,MAAMkF,gBAAgB,GAAGhE,QAAQ;MACjC,MAAMmE,mBAAmB,GAAGjE,WAAW;MACvCD,WAAW,CAAC+B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACF,CAAC,IAAIA,CAAC,CAACb,EAAE,KAAKA,EAAE,CAAC,CAAC;MAClD1C,cAAc,CAAC6B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACC,MAAM,KAAKxB,EAAE,IAAIuB,CAAC,CAACE,MAAM,KAAKzB,EAAE,CAAC,CAAC;;MAE5E;MACA,IAAI;QACF,MAAMvE,UAAU,CAAC4F,YAAY,CAACrB,EAAE,CAAC;QACjCtE,KAAK,CAACoF,OAAO,CAAC,8BAA8B,CAAC;MAC/C,CAAC,CAAC,OAAOjC,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9C;QACAzB,WAAW,CAAC+D,gBAAgB,CAAC;QAC7B7D,cAAc,CAACgE,mBAAmB,CAAC;QACnC5F,KAAK,CAACmD,KAAK,CAAC,4CAA4C,CAAC;QACzD,MAAMA,KAAK;MACb;IACF,CAAC,MAAM;MACL;MACAzB,WAAW,CAAC+B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACF,CAAC,IAAIA,CAAC,CAACb,EAAE,KAAKA,EAAE,CAAC,CAAC;MAClD1C,cAAc,CAAC6B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACC,MAAM,KAAKxB,EAAE,IAAIuB,CAAC,CAACE,MAAM,KAAKzB,EAAE,CAAC,CAAC;IAC9E;EACF,CAAC;EAED,MAAM0B,oBAAoB,GAAG,MAAAA,CAAO1B,EAAU,EAAEU,QAAkC,KAAK;IACrF,MAAMzE,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;;IAEpD;IACAiB,WAAW,CAAC+B,IAAI,IACdA,IAAI,CAACyB,GAAG,CAACC,CAAC,IAAKA,CAAC,CAACb,EAAE,KAAKA,EAAE,GAAG;MAAE,GAAGa,CAAC;MAAEH;IAAS,CAAC,GAAGG,CAAE,CACtD,CAAC;IAED,IAAI5E,KAAK,EAAE;MACT;MACAR,UAAU,CAACwF,YAAY,CAACjB,EAAE,EAAE;QAAEU;MAAS,CAAC,CAAC,CAACiB,KAAK,CAAC9C,KAAK,IAAI;QACvDC,OAAO,CAACD,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;QAC7D;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACAzB,WAAW,CAAC+B,IAAI,IACdA,IAAI,CAACyB,GAAG,CAACC,CAAC,IAAKA,CAAC,CAACb,EAAE,KAAKA,EAAE,GAAG;QAAE,GAAGa,CAAC;QAAEH;MAAS,CAAC,GAAGG,CAAE,CACtD,CAAC;IACH;EACF,CAAC;EAED,MAAMe,aAAa,GAAG,MAAAA,CAAOJ,MAAc,EAAEC,MAAc,KAAK;IAC9D,MAAMxF,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IAEpD,IAAIF,KAAK,EAAE;MACT;MACA,MAAM2D,MAAM,GAAG,aAAaC,IAAI,CAACC,GAAG,CAAC,CAAC,IAAI+B,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE;MACzD,MAAMC,oBAAgC,GAAG;QACvC/B,EAAE,EAAEJ,MAAM;QACV4B,MAAM;QACNC;MACF,CAAC;;MAED;MACA,MAAMO,MAAM,GAAG3E,WAAW,CAAC4E,IAAI,CAACV,CAAC,IAC9BA,CAAC,CAACC,MAAM,KAAKA,MAAM,IAAID,CAAC,CAACE,MAAM,KAAKA,MAAM,IAC1CF,CAAC,CAACC,MAAM,KAAKC,MAAM,IAAIF,CAAC,CAACE,MAAM,KAAKD,MACvC,CAAC;MAED,IAAIQ,MAAM,EAAE;QACV,OAAO,CAAC;MACV;MAEA1E,cAAc,CAAC6B,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAE4C,oBAAoB,CAAC,CAAC;;MAEvD;MACA,IAAI;QACF,MAAMG,aAAa,GAAG,MAAMzG,UAAU,CAAC0G,gBAAgB,CAACX,MAAM,EAAEC,MAAM,CAAC;QACvE;QACAnE,cAAc,CAAC6B,IAAI,IAAIA,IAAI,CAACyB,GAAG,CAACW,CAAC,IAAIA,CAAC,CAACvB,EAAE,KAAKJ,MAAM,GAAGsC,aAAa,GAAGX,CAAC,CAAC,CAAC;QAC1E7F,KAAK,CAACoF,OAAO,CAAC,qBAAqB,CAAC;MACtC,CAAC,CAAC,OAAOjC,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;QAClD;QACAvB,cAAc,CAAC6B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACvB,EAAE,KAAKJ,MAAM,CAAC,CAAC;QACzDlE,KAAK,CAACmD,KAAK,CAAC,8BAA8B,CAAC;QAC3C,MAAMA,KAAK;MACb;IACF,CAAC,MAAM;MACL;MACA,MAAMqD,aAAyB,GAAG;QAChClC,EAAE,EAAE,cAAcH,IAAI,CAACC,GAAG,CAAC,CAAC,IAAI+B,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE;QAC/CN,MAAM;QACNC;MACF,CAAC;MACDnE,cAAc,CAAC6B,IAAI,IAAI;QACrB,MAAM6C,MAAM,GAAG7C,IAAI,CAAC8C,IAAI,CAACV,CAAC,IACvBA,CAAC,CAACC,MAAM,KAAKA,MAAM,IAAID,CAAC,CAACE,MAAM,KAAKA,MAAM,IAC1CF,CAAC,CAACC,MAAM,KAAKC,MAAM,IAAIF,CAAC,CAACE,MAAM,KAAKD,MACvC,CAAC;QACD,IAAIQ,MAAM,EAAE;UACV,OAAO7C,IAAI;QACb;QACA,OAAO,CAAC,GAAGA,IAAI,EAAE+C,aAAa,CAAC;MACjC,CAAC,CAAC;IACJ;EACF,CAAC;EAED,MAAME,gBAAgB,GAAG,MAAOpC,EAAU,IAAK;IAC7C,MAAM/D,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,gBAAgB,CAAC;IAEpD,IAAIF,KAAK,EAAE;MACT;MACA,MAAMqF,mBAAmB,GAAGjE,WAAW;MACvCC,cAAc,CAAC6B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACvB,EAAE,KAAKA,EAAE,CAAC,CAAC;;MAErD;MACA,IAAI;QACF,MAAMvE,UAAU,CAAC2G,gBAAgB,CAACpC,EAAE,CAAC;QACrCtE,KAAK,CAACoF,OAAO,CAAC,qBAAqB,CAAC;MACtC,CAAC,CAAC,OAAOjC,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;QAClD;QACAvB,cAAc,CAACgE,mBAAmB,CAAC;QACnC5F,KAAK,CAACmD,KAAK,CAAC,8BAA8B,CAAC;QAC3C,MAAMA,KAAK;MACb;IACF,CAAC,MAAM;MACL;MACAvB,cAAc,CAAC6B,IAAI,IAAIA,IAAI,CAAC4B,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACvB,EAAE,KAAKA,EAAE,CAAC,CAAC;IACvD;EACF,CAAC;EAED,MAAMqC,cAAc,GAAGA,CAAA,KAAM;IAC3B7E,WAAW,CAAC2B,IAAI,IAAI,CAACA,IAAI,CAAC;EAC5B,CAAC;EAED,MAAMmD,YAAY,GAAGA,CAAA,KAAM;IACzBlF,WAAW,CAAC,EAAE,CAAC;IACfE,cAAc,CAAC,EAAE,CAAC;IAClBQ,aAAa,CAAC,KAAK,CAAC;IACpBF,UAAU,CAAC,IAAI,CAAC;IAChB;IACA,MAAMf,QAAQ,GAAGb,WAAW,CAAC,CAAC;IAC9BE,YAAY,CAACqG,UAAU,CAAC1F,QAAQ,CAAC;IACjC;IACAX,YAAY,CAACqG,UAAU,CAACxG,WAAW,CAAC;EACtC,CAAC;EAED,oBACEH,OAAA,CAACC,aAAa,CAAC2G,QAAQ;IACrBC,KAAK,EAAE;MACLtF,QAAQ;MACRE,WAAW;MACXE,QAAQ;MACRE,OAAO;MACPE,OAAO;MACP+B,SAAS;MACTuB,YAAY;MACZI,YAAY;MACZK,oBAAoB;MACpBE,aAAa;MACbQ,gBAAgB;MAChBC,cAAc;MACdtE,WAAW;MACXgB,gBAAgB;MAChBuD;IACF,CAAE;IAAArF,QAAA,EAEDA;EAAQ;IAAAyF,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACa,CAAC;AAE7B,CAAC;AAAC3F,EAAA,CA/WWF,cAAiD;AAAA8F,EAAA,GAAjD9F,cAAiD;AAiX9D,OAAO,MAAM+F,SAAS,GAAGA,CAAA,KAAM;EAAAC,GAAA;EAC7B,MAAMC,OAAO,GAAG3H,UAAU,CAACO,aAAa,CAAC;EACzC,IAAI,CAACoH,OAAO,EAAE;IACZ,MAAM,IAAItC,KAAK,CAAC,8CAA8C,CAAC;EACjE;EACA,OAAOsC,OAAO;AAChB,CAAC;AAACD,GAAA,CANWD,SAAS;AAAA,IAAAD,EAAA;AAAAI,YAAA,CAAAJ,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}